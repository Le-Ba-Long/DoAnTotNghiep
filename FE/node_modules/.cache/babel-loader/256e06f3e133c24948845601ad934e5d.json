{"ast":null,"code":"import _slicedToArray from \"F:/Do An Tot Nghiep/FE/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { createDelegatedEventHandler } from '../utils/utils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat } from '../utils/text-field-helper';\nexport var useMaskedInput = function useMaskedInput(_ref) {\n  var _ref$acceptRegex = _ref.acceptRegex,\n      acceptRegex = _ref$acceptRegex === void 0 ? /[\\d]/gi : _ref$acceptRegex,\n      disabled = _ref.disabled,\n      disableMaskedInput = _ref.disableMaskedInput,\n      ignoreInvalidInputs = _ref.ignoreInvalidInputs,\n      inputFormat = _ref.inputFormat,\n      inputProps = _ref.inputProps,\n      label = _ref.label,\n      mask = _ref.mask,\n      onChange = _ref.onChange,\n      rawValue = _ref.rawValue,\n      readOnly = _ref.readOnly,\n      rifmFormatter = _ref.rifmFormatter,\n      TextFieldProps = _ref.TextFieldProps,\n      validationError = _ref.validationError;\n  var utils = useUtils();\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      isFocused = _React$useState2[0],\n      setIsFocused = _React$useState2[1];\n\n  var formatHelperText = utils.getFormatHelperText(inputFormat);\n  var shouldUseMaskedInput = React.useMemo(function () {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (!mask || disableMaskedInput) {\n      return false;\n    }\n\n    return checkMaskIsValidForCurrentFormat(mask, inputFormat, acceptRegex, utils);\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  var formatter = React.useMemo(function () {\n    return shouldUseMaskedInput && mask ? maskedDateFormatter(mask, acceptRegex) : function (st) {\n      return st;\n    };\n  }, [acceptRegex, mask, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  var currentInputValue = getDisplayDate(utils, rawValue, inputFormat);\n\n  var _React$useState3 = React.useState(currentInputValue),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      innerInputValue = _React$useState4[0],\n      setInnerInputValue = _React$useState4[1];\n\n  var previousInputValueRef = React.useRef(currentInputValue);\n  React.useEffect(function () {\n    previousInputValueRef.current = currentInputValue;\n  }, [currentInputValue]);\n  var notTyping = !isFocused;\n  var valueChanged = previousInputValueRef.current !== currentInputValue; // Update the input value only if the value changed outside of typing\n\n  if (notTyping && valueChanged && (rawValue === null || utils.isValid(rawValue))) {\n    if (currentInputValue !== innerInputValue) {\n      setInnerInputValue(currentInputValue);\n    }\n  }\n\n  var handleChange = function handleChange(text) {\n    var finalString = text === '' || text === mask ? '' : text;\n    setInnerInputValue(finalString);\n    var date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    onChange(date, finalString || undefined);\n  };\n\n  var rifmProps = useRifm({\n    value: innerInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  var inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerInputValue,\n    onChange: function onChange(event) {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label: label,\n    disabled: disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled: disabled,\n      placeholder: formatHelperText,\n      readOnly: readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps, {\n      onFocus: createDelegatedEventHandler(function () {\n        setIsFocused(true);\n      }, inputProps == null ? void 0 : inputProps.onFocus),\n      onBlur: createDelegatedEventHandler(function () {\n        setIsFocused(false);\n      }, inputProps == null ? void 0 : inputProps.onBlur)\n    })\n  }, TextFieldProps);\n};","map":{"version":3,"names":["_extends","React","useRifm","useUtils","createDelegatedEventHandler","maskedDateFormatter","getDisplayDate","checkMaskIsValidForCurrentFormat","useMaskedInput","acceptRegex","disabled","disableMaskedInput","ignoreInvalidInputs","inputFormat","inputProps","label","mask","onChange","rawValue","readOnly","rifmFormatter","TextFieldProps","validationError","utils","useState","isFocused","setIsFocused","formatHelperText","getFormatHelperText","shouldUseMaskedInput","useMemo","formatter","st","currentInputValue","innerInputValue","setInnerInputValue","previousInputValueRef","useRef","useEffect","current","notTyping","valueChanged","isValid","handleChange","text","finalString","date","parse","undefined","rifmProps","value","format","inputStateArgs","event","currentTarget","error","placeholder","type","onFocus","onBlur"],"sources":["F:/Do An Tot Nghiep/FE/node_modules/@mui/lab/node_modules/@mui/x-date-pickers/internals/hooks/useMaskedInput.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { createDelegatedEventHandler } from '../utils/utils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const [isFocused, setIsFocused] = React.useState(false);\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const shouldUseMaskedInput = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (!mask || disableMaskedInput) {\n      return false;\n    }\n\n    return checkMaskIsValidForCurrentFormat(mask, inputFormat, acceptRegex, utils);\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && mask ? maskedDateFormatter(mask, acceptRegex) : st => st, [acceptRegex, mask, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const currentInputValue = getDisplayDate(utils, rawValue, inputFormat);\n  const [innerInputValue, setInnerInputValue] = React.useState(currentInputValue);\n  const previousInputValueRef = React.useRef(currentInputValue);\n  React.useEffect(() => {\n    previousInputValueRef.current = currentInputValue;\n  }, [currentInputValue]);\n  const notTyping = !isFocused;\n  const valueChanged = previousInputValueRef.current !== currentInputValue; // Update the input value only if the value changed outside of typing\n\n  if (notTyping && valueChanged && (rawValue === null || utils.isValid(rawValue))) {\n    if (currentInputValue !== innerInputValue) {\n      setInnerInputValue(currentInputValue);\n    }\n  }\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps, {\n      onFocus: createDelegatedEventHandler(() => {\n        setIsFocused(true);\n      }, inputProps == null ? void 0 : inputProps.onFocus),\n      onBlur: createDelegatedEventHandler(() => {\n        setIsFocused(false);\n      }, inputProps == null ? void 0 : inputProps.onBlur)\n    })\n  }, TextFieldProps);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}